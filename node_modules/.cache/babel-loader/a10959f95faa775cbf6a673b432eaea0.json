{"ast":null,"code":"var _typeof2 = require(\"/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/node_modules/@babel/runtime/helpers/typeof\");\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n};\n/*! flatpickr v2.6.3, @license MIT */\n\n\nfunction Flatpickr(element, config) {\n  var self = this;\n  self._ = {};\n  self._.afterDayAnim = afterDayAnim;\n  self.changeMonth = changeMonth;\n  self.changeYear = changeYear;\n  self.clear = clear;\n  self.close = close;\n  self._createElement = createElement;\n  self.destroy = destroy;\n  self.isEnabled = isEnabled;\n  self.jumpToDate = jumpToDate;\n  self.open = open;\n  self.redraw = redraw;\n  self.set = set;\n  self.setDate = setDate;\n  self.toggle = toggle;\n\n  function init() {\n    self.element = self.input = element;\n    self.instanceConfig = config || {};\n    self.parseDate = Flatpickr.prototype.parseDate.bind(self);\n    self.formatDate = Flatpickr.prototype.formatDate.bind(self);\n    setupFormats();\n    parseConfig();\n    setupLocale();\n    setupInputs();\n    setupDates();\n    setupHelperFunctions();\n    self.isOpen = false;\n    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === \"single\" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    if (!self.isMobile) build();\n    bindEvents();\n\n    if (self.selectedDates.length || self.config.noCalendar) {\n      if (self.config.enableTime) {\n        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : null);\n      }\n\n      updateValue();\n    }\n\n    if (self.config.weekNumbers) {\n      self.calendarContainer.style.width = self.daysContainer.offsetWidth + self.weekWrapper.offsetWidth + \"px\";\n    }\n\n    self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;\n    if (!self.isMobile) positionCalendar();\n    triggerEvent(\"Ready\");\n  }\n  /**\n   * Binds a function to the current flatpickr instance\n   * @param {Function} fn the function\n   * @return {Function} the function bound to the instance\n   */\n\n\n  function bindToInstance(fn) {\n    return fn.bind(self);\n  }\n  /**\n   * The handler for all events targeting the time inputs\n   * @param {Event} e the event - \"input\", \"wheel\", \"increment\", etc\n   */\n\n\n  function updateTime(e) {\n    if (self.config.noCalendar && !self.selectedDates.length) // picking time only\n      self.selectedDates = [self.now];\n    timeWrapper(e);\n    if (!self.selectedDates.length) return;\n\n    if (!self.minDateHasTime || e.type !== \"input\" || e.target.value.length >= 2) {\n      setHoursFromInputs();\n      updateValue();\n    } else {\n      setTimeout(function () {\n        setHoursFromInputs();\n        updateValue();\n      }, 1000);\n    }\n  }\n  /**\n   * Syncs the selected date object time with user's time input\n   */\n\n\n  function setHoursFromInputs() {\n    if (!self.config.enableTime) return;\n    var hours = (parseInt(self.hourElement.value, 10) || 0) % (self.amPM ? 12 : 24),\n        minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,\n        seconds = self.config.enableSeconds ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;\n    if (self.amPM !== undefined) hours = hours % 12 + 12 * (self.amPM.textContent === \"PM\");\n\n    if (self.minDateHasTime && compareDates(self.latestSelectedDateObj, self.config.minDate) === 0) {\n      hours = Math.max(hours, self.config.minDate.getHours());\n      if (hours === self.config.minDate.getHours()) minutes = Math.max(minutes, self.config.minDate.getMinutes());\n    }\n\n    if (self.maxDateHasTime && compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0) {\n      hours = Math.min(hours, self.config.maxDate.getHours());\n      if (hours === self.config.maxDate.getHours()) minutes = Math.min(minutes, self.config.maxDate.getMinutes());\n    }\n\n    setHours(hours, minutes, seconds);\n  }\n  /**\n   * Syncs time input values with a date\n   * @param {Date} dateObj the date to sync with\n   */\n\n\n  function setHoursFromDate(dateObj) {\n    var date = dateObj || self.latestSelectedDateObj;\n    if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());\n  }\n  /**\n   * Sets the hours, minutes, and optionally seconds\n   * of the latest selected date object and the\n   * corresponding time inputs\n   * @param {Number} hours the hour. whether its military\n   *                 or am-pm gets inferred from config\n   * @param {Number} minutes the minutes\n   * @param {Number} seconds the seconds (optional)\n   */\n\n\n  function setHours(hours, minutes, seconds) {\n    if (self.selectedDates.length) {\n      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);\n    }\n\n    if (!self.config.enableTime || self.isMobile) return;\n    self.hourElement.value = self.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * (hours % 12 === 0) : hours);\n    self.minuteElement.value = self.pad(minutes);\n    if (!self.config.time_24hr) self.amPM.textContent = hours >= 12 ? \"PM\" : \"AM\";\n    if (self.config.enableSeconds === true) self.secondElement.value = self.pad(seconds);\n  }\n  /**\n   * Handles the year input and incrementing events\n   * @param {Event} event the keyup or increment event\n   */\n\n\n  function onYearInput(event) {\n    var year = event.target.value;\n    if (event.delta) year = (parseInt(year) + event.delta).toString();\n\n    if (year.length === 4 || event.key === \"Enter\") {\n      self.currentYearElement.blur();\n      if (!/[^\\d]/.test(year)) changeYear(year);\n    }\n  }\n  /**\n   * Essentially addEventListener + tracking\n   * @param {Element} element the element to addEventListener to\n   * @param {String} event the event name\n   * @param {Function} handler the event handler\n   */\n\n\n  function bind(element, event, handler) {\n    if (event instanceof Array) return event.forEach(function (ev) {\n      return bind(element, ev, handler);\n    });\n    if (element instanceof Array) return element.forEach(function (el) {\n      return bind(el, event, handler);\n    });\n    element.addEventListener(event, handler);\n\n    self._handlers.push({\n      element: element,\n      event: event,\n      handler: handler\n    });\n  }\n  /**\n   * A mousedown handler which mimics click.\n   * Minimizes latency, since we don't need to wait for mouseup in most cases.\n   * Also, avoids handling right clicks.\n   *\n   * @param {Function} handler the event handler\n   */\n\n\n  function onClick(handler) {\n    return function (evt) {\n      return evt.which === 1 && handler(evt);\n    };\n  }\n  /**\n   * Adds all the necessary event listeners\n   */\n\n\n  function bindEvents() {\n    self._handlers = [];\n    self._animationLoop = [];\n\n    if (self.config.wrap) {\n      [\"open\", \"close\", \"toggle\", \"clear\"].forEach(function (evt) {\n        Array.prototype.forEach.call(self.element.querySelectorAll(\"[data-\" + evt + \"]\"), function (el) {\n          return bind(el, \"mousedown\", onClick(self[evt]));\n        });\n      });\n    }\n\n    if (self.isMobile) return setupMobile();\n    self.debouncedResize = debounce(onResize, 50);\n\n    self.triggerChange = function () {\n      triggerEvent(\"Change\");\n    };\n\n    self.debouncedChange = debounce(self.triggerChange, 300);\n    if (self.config.mode === \"range\" && self.daysContainer) bind(self.daysContainer, \"mouseover\", function (e) {\n      return onMouseOver(e.target);\n    });\n    bind(window.document.body, \"keydown\", onKeyDown);\n    if (!self.config.static) bind(self._input, \"keydown\", onKeyDown);\n    if (!self.config.inline && !self.config.static) bind(window, \"resize\", self.debouncedResize);\n    if (window.ontouchstart !== undefined) bind(window.document, \"touchstart\", documentClick);\n    bind(window.document, \"mousedown\", onClick(documentClick));\n    bind(self._input, \"blur\", documentClick);\n    if (self.config.clickOpens === true) bind(self._input, \"focus\", self.open);\n\n    if (!self.config.noCalendar) {\n      self.monthNav.addEventListener(\"wheel\", function (e) {\n        return e.preventDefault();\n      });\n      bind(self.monthNav, \"wheel\", debounce(onMonthNavScroll, 10));\n      bind(self.monthNav, \"mousedown\", onClick(onMonthNavClick));\n      bind(self.monthNav, [\"keyup\", \"increment\"], onYearInput);\n      bind(self.daysContainer, \"mousedown\", onClick(selectDate));\n\n      if (self.config.animate) {\n        bind(self.daysContainer, [\"webkitAnimationEnd\", \"animationend\"], animateDays);\n        bind(self.monthNav, [\"webkitAnimationEnd\", \"animationend\"], animateMonths);\n      }\n    }\n\n    if (self.config.enableTime) {\n      var selText = function selText(e) {\n        return e.target.select();\n      };\n\n      bind(self.timeContainer, [\"wheel\", \"input\", \"increment\"], updateTime);\n      bind(self.timeContainer, \"mousedown\", onClick(timeIncrement));\n      bind(self.timeContainer, [\"wheel\", \"increment\"], self.debouncedChange);\n      bind(self.timeContainer, \"input\", self.triggerChange);\n      bind([self.hourElement, self.minuteElement], \"focus\", selText);\n      if (self.secondElement !== undefined) bind(self.secondElement, \"focus\", function () {\n        return self.secondElement.select();\n      });\n\n      if (self.amPM !== undefined) {\n        bind(self.amPM, \"mousedown\", onClick(function (e) {\n          updateTime(e);\n          self.triggerChange(e);\n        }));\n      }\n    }\n  }\n\n  function processPostDayAnimation() {\n    for (var i = self._animationLoop.length; i--;) {\n      self._animationLoop[i]();\n\n      self._animationLoop.splice(i, 1);\n    }\n  }\n  /**\n   * Removes the day container that slided out of view\n   * @param {Event} e the animation event\n   */\n\n\n  function animateDays(e) {\n    if (self.daysContainer.childNodes.length > 1) {\n      switch (e.animationName) {\n        case \"fpSlideLeft\":\n          self.daysContainer.lastChild.classList.remove(\"slideLeftNew\");\n          self.daysContainer.removeChild(self.daysContainer.firstChild);\n          self.days = self.daysContainer.firstChild;\n          processPostDayAnimation();\n          break;\n\n        case \"fpSlideRight\":\n          self.daysContainer.firstChild.classList.remove(\"slideRightNew\");\n          self.daysContainer.removeChild(self.daysContainer.lastChild);\n          self.days = self.daysContainer.firstChild;\n          processPostDayAnimation();\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n  /**\n   * Removes the month element that animated out of view\n   * @param {Event} e the animation event\n   */\n\n\n  function animateMonths(e) {\n    switch (e.animationName) {\n      case \"fpSlideLeftNew\":\n      case \"fpSlideRightNew\":\n        self.navigationCurrentMonth.classList.remove(\"slideLeftNew\");\n        self.navigationCurrentMonth.classList.remove(\"slideRightNew\");\n        var nav = self.navigationCurrentMonth;\n\n        while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {\n          self.monthNav.removeChild(nav.nextSibling);\n        }\n\n        while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {\n          self.monthNav.removeChild(nav.previousSibling);\n        }\n\n        self.oldCurMonth = null;\n        break;\n    }\n  }\n  /**\n   * Set the calendar view to a particular date.\n   * @param {Date} jumpDate the date to set the view to\n   */\n\n\n  function jumpToDate(jumpDate) {\n    jumpDate = jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);\n\n    try {\n      self.currentYear = jumpDate.getFullYear();\n      self.currentMonth = jumpDate.getMonth();\n    } catch (e) {\n      /* istanbul ignore next */\n      console.error(e.stack);\n      /* istanbul ignore next */\n\n      console.warn(\"Invalid date supplied: \" + jumpDate);\n    }\n\n    self.redraw();\n  }\n  /**\n   * The up/down arrow handler for time inputs\n   * @param {Event} e the click event\n   */\n\n\n  function timeIncrement(e) {\n    if (~e.target.className.indexOf(\"arrow\")) incrementNumInput(e, e.target.classList.contains(\"arrowUp\") ? 1 : -1);\n  }\n  /**\n   * Increments/decrements the value of input associ-\n   * ated with the up/down arrow by dispatching an\n   * \"increment\" event on the input.\n   *\n   * @param {Event} e the click event\n   * @param {Number} delta the diff (usually 1 or -1)\n   * @param {Element} inputElem the input element\n   */\n\n\n  function incrementNumInput(e, delta, inputElem) {\n    var input = inputElem || e.target.parentNode.childNodes[0];\n    var event = createEvent(\"increment\");\n    event.delta = delta;\n    input.dispatchEvent(event);\n  }\n\n  function createNumberInput(inputClassName) {\n    var wrapper = createElement(\"div\", \"numInputWrapper\"),\n        numInput = createElement(\"input\", \"numInput \" + inputClassName),\n        arrowUp = createElement(\"span\", \"arrowUp\"),\n        arrowDown = createElement(\"span\", \"arrowDown\");\n    numInput.type = \"text\";\n    numInput.pattern = \"\\\\d*\";\n    wrapper.appendChild(numInput);\n    wrapper.appendChild(arrowUp);\n    wrapper.appendChild(arrowDown);\n    return wrapper;\n  }\n\n  function build() {\n    var fragment = window.document.createDocumentFragment();\n    self.calendarContainer = createElement(\"div\", \"flatpickr-calendar\");\n    self.calendarContainer.tabIndex = -1;\n\n    if (!self.config.noCalendar) {\n      fragment.appendChild(buildMonthNav());\n      self.innerContainer = createElement(\"div\", \"flatpickr-innerContainer\");\n      if (self.config.weekNumbers) self.innerContainer.appendChild(buildWeeks());\n      self.rContainer = createElement(\"div\", \"flatpickr-rContainer\");\n      self.rContainer.appendChild(buildWeekdays());\n\n      if (!self.daysContainer) {\n        self.daysContainer = createElement(\"div\", \"flatpickr-days\");\n        self.daysContainer.tabIndex = -1;\n      }\n\n      buildDays();\n      self.rContainer.appendChild(self.daysContainer);\n      self.innerContainer.appendChild(self.rContainer);\n      fragment.appendChild(self.innerContainer);\n    }\n\n    if (self.config.enableTime) fragment.appendChild(buildTime());\n    toggleClass(self.calendarContainer, \"rangeMode\", self.config.mode === \"range\");\n    toggleClass(self.calendarContainer, \"animate\", self.config.animate);\n    self.calendarContainer.appendChild(fragment);\n    var customAppend = self.config.appendTo && self.config.appendTo.nodeType;\n\n    if (self.config.inline || self.config.static) {\n      self.calendarContainer.classList.add(self.config.inline ? \"inline\" : \"static\");\n\n      if (self.config.inline && !customAppend) {\n        return self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);\n      }\n\n      if (self.config.static) {\n        var wrapper = createElement(\"div\", \"flatpickr-wrapper\");\n        self.element.parentNode.insertBefore(wrapper, self.element);\n        wrapper.appendChild(self.element);\n        if (self.altInput) wrapper.appendChild(self.altInput);\n        wrapper.appendChild(self.calendarContainer);\n        return;\n      }\n    }\n\n    (customAppend ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);\n  }\n\n  function createDay(className, date, dayNumber, i) {\n    var dateIsEnabled = isEnabled(date, true),\n        dayElement = createElement(\"span\", \"flatpickr-day \" + className, date.getDate());\n    dayElement.dateObj = date;\n    dayElement.$i = i;\n    dayElement.setAttribute(\"aria-label\", self.formatDate(date, self.config.ariaDateFormat));\n\n    if (compareDates(date, self.now) === 0) {\n      self.todayDateElem = dayElement;\n      dayElement.classList.add(\"today\");\n    }\n\n    if (dateIsEnabled) {\n      dayElement.tabIndex = -1;\n\n      if (isDateSelected(date)) {\n        dayElement.classList.add(\"selected\");\n        self.selectedDateElem = dayElement;\n\n        if (self.config.mode === \"range\") {\n          toggleClass(dayElement, \"startRange\", compareDates(date, self.selectedDates[0]) === 0);\n          toggleClass(dayElement, \"endRange\", compareDates(date, self.selectedDates[1]) === 0);\n        }\n      }\n    } else {\n      dayElement.classList.add(\"disabled\");\n      if (self.selectedDates[0] && date > self.minRangeDate && date < self.selectedDates[0]) self.minRangeDate = date;else if (self.selectedDates[0] && date < self.maxRangeDate && date > self.selectedDates[0]) self.maxRangeDate = date;\n    }\n\n    if (self.config.mode === \"range\") {\n      if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add(\"inRange\");\n      if (self.selectedDates.length === 1 && (date < self.minRangeDate || date > self.maxRangeDate)) dayElement.classList.add(\"notAllowed\");\n    }\n\n    if (self.config.weekNumbers && className !== \"prevMonthDay\" && dayNumber % 7 === 1) {\n      self.weekNumbers.insertAdjacentHTML(\"beforeend\", \"<span class='disabled flatpickr-day'>\" + self.config.getWeek(date) + \"</span>\");\n    }\n\n    triggerEvent(\"DayCreate\", dayElement);\n    return dayElement;\n  }\n\n  function focusOnDay(currentIndex, offset) {\n    var newIndex = currentIndex + offset || 0,\n        targetNode = currentIndex !== undefined ? self.days.childNodes[newIndex] : self.selectedDateElem || self.todayDateElem || self.days.childNodes[0],\n        focus = function focus() {\n      targetNode = targetNode || self.days.childNodes[newIndex];\n      targetNode.focus();\n      if (self.config.mode === \"range\") onMouseOver(targetNode);\n    };\n\n    if (targetNode === undefined && offset !== 0) {\n      if (offset > 0) {\n        self.changeMonth(1);\n        newIndex = newIndex % 42;\n      } else if (offset < 0) {\n        self.changeMonth(-1);\n        newIndex += 42;\n      }\n\n      return afterDayAnim(focus);\n    }\n\n    focus();\n  }\n\n  function afterDayAnim(fn) {\n    if (self.config.animate === true) return self._animationLoop.push(fn);\n    fn();\n  }\n\n  function buildDays(delta) {\n    var firstOfMonth = (new Date(self.currentYear, self.currentMonth, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7,\n        isRangeMode = self.config.mode === \"range\";\n    self.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);\n    self.selectedDateElem = undefined;\n    self.todayDateElem = undefined;\n    var daysInMonth = self.utils.getDaysinMonth(),\n        days = window.document.createDocumentFragment();\n    var dayNumber = self.prevMonthDays + 1 - firstOfMonth,\n        dayIndex = 0;\n    if (self.config.weekNumbers && self.weekNumbers.firstChild) self.weekNumbers.textContent = \"\";\n\n    if (isRangeMode) {\n      // const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;\n      self.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);\n      self.maxRangeDate = new Date(self.currentYear, self.currentMonth + 1, (42 - firstOfMonth) % daysInMonth);\n    } // prepend days from the ending of previous month\n\n\n    for (; dayNumber <= self.prevMonthDays; dayNumber++, dayIndex++) {\n      days.appendChild(createDay(\"prevMonthDay\", new Date(self.currentYear, self.currentMonth - 1, dayNumber), dayNumber, dayIndex));\n    } // Start at 1 since there is no 0th day\n\n\n    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {\n      days.appendChild(createDay(\"\", new Date(self.currentYear, self.currentMonth, dayNumber), dayNumber, dayIndex));\n    } // append days from the next month\n\n\n    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth; dayNum++, dayIndex++) {\n      days.appendChild(createDay(\"nextMonthDay\", new Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth), dayNum, dayIndex));\n    }\n\n    if (isRangeMode && self.selectedDates.length === 1 && days.childNodes[0]) {\n      self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > days.childNodes[0].dateObj;\n      self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);\n    } else updateNavigationCurrentMonth();\n\n    var dayContainer = createElement(\"div\", \"dayContainer\");\n    dayContainer.appendChild(days);\n    if (!self.config.animate || delta === undefined) clearNode(self.daysContainer);else {\n      while (self.daysContainer.childNodes.length > 1) {\n        self.daysContainer.removeChild(self.daysContainer.firstChild);\n      }\n    }\n    if (delta >= 0) self.daysContainer.appendChild(dayContainer);else self.daysContainer.insertBefore(dayContainer, self.daysContainer.firstChild);\n    self.days = self.daysContainer.firstChild;\n    return self.daysContainer;\n  }\n\n  function clearNode(node) {\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n  }\n\n  function buildMonthNav() {\n    var monthNavFragment = window.document.createDocumentFragment();\n    self.monthNav = createElement(\"div\", \"flatpickr-month\");\n    self.prevMonthNav = createElement(\"span\", \"flatpickr-prev-month\");\n    self.prevMonthNav.innerHTML = self.config.prevArrow;\n    self.currentMonthElement = createElement(\"span\", \"cur-month\");\n    self.currentMonthElement.title = self.l10n.scrollTitle;\n    var yearInput = createNumberInput(\"cur-year\");\n    self.currentYearElement = yearInput.childNodes[0];\n    self.currentYearElement.title = self.l10n.scrollTitle;\n    if (self.config.minDate) self.currentYearElement.min = self.config.minDate.getFullYear();\n\n    if (self.config.maxDate) {\n      self.currentYearElement.max = self.config.maxDate.getFullYear();\n      self.currentYearElement.disabled = self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();\n    }\n\n    self.nextMonthNav = createElement(\"span\", \"flatpickr-next-month\");\n    self.nextMonthNav.innerHTML = self.config.nextArrow;\n    self.navigationCurrentMonth = createElement(\"span\", \"flatpickr-current-month\");\n    self.navigationCurrentMonth.appendChild(self.currentMonthElement);\n    self.navigationCurrentMonth.appendChild(yearInput);\n    monthNavFragment.appendChild(self.prevMonthNav);\n    monthNavFragment.appendChild(self.navigationCurrentMonth);\n    monthNavFragment.appendChild(self.nextMonthNav);\n    self.monthNav.appendChild(monthNavFragment);\n    Object.defineProperty(self, \"_hidePrevMonthArrow\", {\n      get: function get() {\n        return this.__hidePrevMonthArrow;\n      },\n      set: function set(bool) {\n        if (this.__hidePrevMonthArrow !== bool) self.prevMonthNav.style.display = bool ? \"none\" : \"block\";\n        this.__hidePrevMonthArrow = bool;\n      }\n    });\n    Object.defineProperty(self, \"_hideNextMonthArrow\", {\n      get: function get() {\n        return this.__hideNextMonthArrow;\n      },\n      set: function set(bool) {\n        if (this.__hideNextMonthArrow !== bool) self.nextMonthNav.style.display = bool ? \"none\" : \"block\";\n        this.__hideNextMonthArrow = bool;\n      }\n    });\n    updateNavigationCurrentMonth();\n    return self.monthNav;\n  }\n\n  function buildTime() {\n    self.calendarContainer.classList.add(\"hasTime\");\n    if (self.config.noCalendar) self.calendarContainer.classList.add(\"noCalendar\");\n    self.timeContainer = createElement(\"div\", \"flatpickr-time\");\n    self.timeContainer.tabIndex = -1;\n    var separator = createElement(\"span\", \"flatpickr-time-separator\", \":\");\n    var hourInput = createNumberInput(\"flatpickr-hour\");\n    self.hourElement = hourInput.childNodes[0];\n    var minuteInput = createNumberInput(\"flatpickr-minute\");\n    self.minuteElement = minuteInput.childNodes[0];\n    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;\n    self.hourElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.defaultHour);\n    self.minuteElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);\n    self.hourElement.step = self.config.hourIncrement;\n    self.minuteElement.step = self.config.minuteIncrement;\n    self.hourElement.min = self.config.time_24hr ? 0 : 1;\n    self.hourElement.max = self.config.time_24hr ? 23 : 12;\n    self.minuteElement.min = 0;\n    self.minuteElement.max = 59;\n    self.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;\n    self.timeContainer.appendChild(hourInput);\n    self.timeContainer.appendChild(separator);\n    self.timeContainer.appendChild(minuteInput);\n    if (self.config.time_24hr) self.timeContainer.classList.add(\"time24hr\");\n\n    if (self.config.enableSeconds) {\n      self.timeContainer.classList.add(\"hasSeconds\");\n      var secondInput = createNumberInput(\"flatpickr-second\");\n      self.secondElement = secondInput.childNodes[0];\n      self.secondElement.value = self.latestSelectedDateObj ? self.pad(self.latestSelectedDateObj.getSeconds()) : \"00\";\n      self.secondElement.step = self.minuteElement.step;\n      self.secondElement.min = self.minuteElement.min;\n      self.secondElement.max = self.minuteElement.max;\n      self.timeContainer.appendChild(createElement(\"span\", \"flatpickr-time-separator\", \":\"));\n      self.timeContainer.appendChild(secondInput);\n    }\n\n    if (!self.config.time_24hr) {\n      // add self.amPM if appropriate\n      self.amPM = createElement(\"span\", \"flatpickr-am-pm\", [\"AM\", \"PM\"][self.hourElement.value > 11 | 0]);\n      self.amPM.title = self.l10n.toggleTitle;\n      self.amPM.tabIndex = -1;\n      self.timeContainer.appendChild(self.amPM);\n    }\n\n    return self.timeContainer;\n  }\n\n  function buildWeekdays() {\n    if (!self.weekdayContainer) self.weekdayContainer = createElement(\"div\", \"flatpickr-weekdays\");\n    var firstDayOfWeek = self.l10n.firstDayOfWeek;\n    var weekdays = self.l10n.weekdays.shorthand.slice();\n\n    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {\n      weekdays = [].concat(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));\n    }\n\n    self.weekdayContainer.innerHTML = \"\\n\\t\\t<span class=flatpickr-weekday>\\n\\t\\t\\t\" + weekdays.join(\"</span><span class=flatpickr-weekday>\") + \"\\n\\t\\t</span>\\n\\t\\t\";\n    return self.weekdayContainer;\n  }\n  /* istanbul ignore next */\n\n\n  function buildWeeks() {\n    self.calendarContainer.classList.add(\"hasWeeks\");\n    self.weekWrapper = createElement(\"div\", \"flatpickr-weekwrapper\");\n    self.weekWrapper.appendChild(createElement(\"span\", \"flatpickr-weekday\", self.l10n.weekAbbreviation));\n    self.weekNumbers = createElement(\"div\", \"flatpickr-weeks\");\n    self.weekWrapper.appendChild(self.weekNumbers);\n    return self.weekWrapper;\n  }\n\n  function changeMonth(value, is_offset, animate) {\n    is_offset = is_offset === undefined || is_offset;\n    var delta = is_offset ? value : value - self.currentMonth;\n    var skipAnimations = !self.config.animate || animate === false;\n    if (delta < 0 && self._hidePrevMonthArrow || delta > 0 && self._hideNextMonthArrow) return;\n    self.currentMonth += delta;\n\n    if (self.currentMonth < 0 || self.currentMonth > 11) {\n      self.currentYear += self.currentMonth > 11 ? 1 : -1;\n      self.currentMonth = (self.currentMonth + 12) % 12;\n      triggerEvent(\"YearChange\");\n    }\n\n    buildDays(!skipAnimations ? delta : undefined);\n\n    if (skipAnimations) {\n      triggerEvent(\"MonthChange\");\n      return updateNavigationCurrentMonth();\n    } // remove possible remnants from clicking too fast\n\n\n    var nav = self.navigationCurrentMonth;\n\n    if (delta < 0) {\n      while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {\n        self.monthNav.removeChild(nav.nextSibling);\n      }\n    } else if (delta > 0) {\n      while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {\n        self.monthNav.removeChild(nav.previousSibling);\n      }\n    }\n\n    self.oldCurMonth = self.navigationCurrentMonth;\n    self.navigationCurrentMonth = self.monthNav.insertBefore(self.oldCurMonth.cloneNode(true), delta > 0 ? self.oldCurMonth.nextSibling : self.oldCurMonth);\n\n    if (delta > 0) {\n      self.daysContainer.firstChild.classList.add(\"slideLeft\");\n      self.daysContainer.lastChild.classList.add(\"slideLeftNew\");\n      self.oldCurMonth.classList.add(\"slideLeft\");\n      self.navigationCurrentMonth.classList.add(\"slideLeftNew\");\n    } else if (delta < 0) {\n      self.daysContainer.firstChild.classList.add(\"slideRightNew\");\n      self.daysContainer.lastChild.classList.add(\"slideRight\");\n      self.oldCurMonth.classList.add(\"slideRight\");\n      self.navigationCurrentMonth.classList.add(\"slideRightNew\");\n    }\n\n    self.currentMonthElement = self.navigationCurrentMonth.firstChild;\n    self.currentYearElement = self.navigationCurrentMonth.lastChild.childNodes[0];\n    updateNavigationCurrentMonth();\n    self.oldCurMonth.firstChild.textContent = self.utils.monthToStr(self.currentMonth - delta);\n    triggerEvent(\"MonthChange\");\n\n    if (document.activeElement && document.activeElement.$i) {\n      var index = document.activeElement.$i;\n      afterDayAnim(function () {\n        focusOnDay(index, 0);\n      });\n    }\n  }\n\n  function clear(triggerChangeEvent) {\n    self.input.value = \"\";\n    if (self.altInput) self.altInput.value = \"\";\n    if (self.mobileInput) self.mobileInput.value = \"\";\n    self.selectedDates = [];\n    self.latestSelectedDateObj = undefined;\n    self.showTimeInput = false;\n    self.redraw();\n    if (triggerChangeEvent !== false) // triggerChangeEvent is true (default) or an Event\n      triggerEvent(\"Change\");\n  }\n\n  function close() {\n    self.isOpen = false;\n\n    if (!self.isMobile) {\n      self.calendarContainer.classList.remove(\"open\");\n\n      self._input.classList.remove(\"active\");\n    }\n\n    triggerEvent(\"Close\");\n  }\n\n  function destroy() {\n    for (var i = self._handlers.length; i--;) {\n      var h = self._handlers[i];\n      h.element.removeEventListener(h.event, h.handler);\n    }\n\n    self._handlers = [];\n\n    if (self.mobileInput) {\n      if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);\n      self.mobileInput = null;\n    } else if (self.calendarContainer && self.calendarContainer.parentNode) self.calendarContainer.parentNode.removeChild(self.calendarContainer);\n\n    if (self.altInput) {\n      self.input.type = \"text\";\n      if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);\n      delete self.altInput;\n    }\n\n    if (self.input) {\n      self.input.type = self.input._type;\n      self.input.classList.remove(\"flatpickr-input\");\n      self.input.removeAttribute(\"readonly\");\n      self.input.value = \"\";\n    }\n\n    [\"_showTimeInput\", \"latestSelectedDateObj\", \"_hideNextMonthArrow\", \"_hidePrevMonthArrow\", \"__hideNextMonthArrow\", \"__hidePrevMonthArrow\", \"isMobile\", \"isOpen\", \"selectedDateElem\", \"minDateHasTime\", \"maxDateHasTime\", \"days\", \"daysContainer\", \"_input\", \"_positionElement\", \"innerContainer\", \"rContainer\", \"monthNav\", \"todayDateElem\", \"calendarContainer\", \"weekdayContainer\", \"prevMonthNav\", \"nextMonthNav\", \"currentMonthElement\", \"currentYearElement\", \"navigationCurrentMonth\", \"selectedDateElem\", \"config\"].forEach(function (k) {\n      return delete self[k];\n    });\n  }\n\n  function isCalendarElem(elem) {\n    if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;\n    return self.calendarContainer.contains(elem);\n  }\n\n  function documentClick(e) {\n    if (self.isOpen && !self.config.inline) {\n      var isCalendarElement = isCalendarElem(e.target);\n      var isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) || // web components\n      e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));\n      var lostFocus = e.type === \"blur\" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;\n\n      if (lostFocus) {\n        e.preventDefault();\n        self.close();\n\n        if (self.config.mode === \"range\" && self.selectedDates.length === 1) {\n          self.clear(false);\n          self.redraw();\n        }\n      }\n    }\n  }\n\n  function changeYear(newYear) {\n    if (!newYear || self.currentYearElement.min && newYear < self.currentYearElement.min || self.currentYearElement.max && newYear > self.currentYearElement.max) return;\n    var newYearNum = parseInt(newYear, 10),\n        isNewYear = self.currentYear !== newYearNum;\n    self.currentYear = newYearNum || self.currentYear;\n\n    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {\n      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);\n    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {\n      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);\n    }\n\n    if (isNewYear) {\n      self.redraw();\n      triggerEvent(\"YearChange\");\n    }\n  }\n\n  function isEnabled(date, timeless) {\n    if (self.config.minDate && compareDates(date, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && compareDates(date, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;\n    if (!self.config.enable.length && !self.config.disable.length) return true;\n    var dateToCheck = self.parseDate(date, null, true); // timeless\n\n    var bool = self.config.enable.length > 0,\n        array = bool ? self.config.enable : self.config.disable;\n\n    for (var i = 0, d; i < array.length; i++) {\n      d = array[i];\n      if (d instanceof Function && d(dateToCheck)) // disabled by function\n        return bool;else if (d instanceof Date && d.getTime() === dateToCheck.getTime()) // disabled by date\n        return bool;else if (typeof d === \"string\" && self.parseDate(d, null, true).getTime() === dateToCheck.getTime()) // disabled by date string\n        return bool;else if ( // disabled by range\n      (typeof d === \"undefined\" ? \"undefined\" : _typeof(d)) === \"object\" && d.from && d.to && dateToCheck >= d.from && dateToCheck <= d.to) return bool;\n    }\n\n    return !bool;\n  }\n\n  function onKeyDown(e) {\n    var isInput = e.target === self._input;\n    var calendarElem = isCalendarElem(e.target);\n    var allowInput = self.config.allowInput;\n    var allowKeydown = self.isOpen && (!allowInput || !isInput);\n    var allowInlineKeydown = self.config.inline && isInput && !allowInput;\n\n    if (e.key === \"Enter\" && allowInput && isInput) {\n      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);\n      return e.target.blur();\n    } else if (calendarElem || allowKeydown || allowInlineKeydown) {\n      var isTimeObj = self.timeContainer && self.timeContainer.contains(e.target);\n\n      switch (e.key) {\n        case \"Enter\":\n          if (isTimeObj) updateValue();else selectDate(e);\n          break;\n\n        case \"Escape\":\n          // escape\n          e.preventDefault();\n          self.close();\n          break;\n\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n          if (!isTimeObj) {\n            e.preventDefault();\n\n            if (self.daysContainer) {\n              var _delta = e.key === \"ArrowRight\" ? 1 : -1;\n\n              if (!e.ctrlKey) focusOnDay(e.target.$i, _delta);else changeMonth(_delta, true);\n            } else if (self.config.enableTime && !isTimeObj) self.hourElement.focus();\n          }\n\n          break;\n\n        case \"ArrowUp\":\n        case \"ArrowDown\":\n          e.preventDefault();\n          var delta = e.key === \"ArrowDown\" ? 1 : -1;\n\n          if (self.daysContainer) {\n            if (e.ctrlKey) {\n              changeYear(self.currentYear - delta);\n              focusOnDay(e.target.$i, 0);\n            } else if (!isTimeObj) focusOnDay(e.target.$i, delta * 7);\n          } else if (self.config.enableTime) {\n            if (!isTimeObj) self.hourElement.focus();\n            updateTime(e);\n          }\n\n          break;\n\n        case \"Tab\":\n          if (e.target === self.hourElement) {\n            e.preventDefault();\n            self.minuteElement.select();\n          } else if (e.target === self.minuteElement && (self.secondElement || self.amPM)) {\n            e.preventDefault();\n            (self.secondElement || self.amPM).focus();\n          } else if (e.target === self.secondElement) {\n            e.preventDefault();\n            self.amPM.focus();\n          }\n\n          break;\n\n        case \"a\":\n          if (e.target === self.amPM) {\n            self.amPM.textContent = \"AM\";\n            setHoursFromInputs();\n            updateValue();\n          }\n\n          break;\n\n        case \"p\":\n          if (e.target === self.amPM) {\n            self.amPM.textContent = \"PM\";\n            setHoursFromInputs();\n            updateValue();\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      triggerEvent(\"KeyDown\", e);\n    }\n  }\n\n  function onMouseOver(elem) {\n    if (self.selectedDates.length !== 1 || !elem.classList.contains(\"flatpickr-day\")) return;\n    var hoverDate = elem.dateObj,\n        initialDate = self.parseDate(self.selectedDates[0], null, true),\n        rangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),\n        rangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),\n        containsDisabled = false;\n\n    for (var t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {\n      if (!isEnabled(new Date(t))) {\n        containsDisabled = true;\n        break;\n      }\n    }\n\n    var _loop = function _loop(timestamp, i) {\n      var outOfRange = timestamp < self.minRangeDate.getTime() || timestamp > self.maxRangeDate.getTime(),\n          dayElem = self.days.childNodes[i];\n\n      if (outOfRange) {\n        self.days.childNodes[i].classList.add(\"notAllowed\");\n        [\"inRange\", \"startRange\", \"endRange\"].forEach(function (c) {\n          dayElem.classList.remove(c);\n        });\n        return \"continue\";\n      } else if (containsDisabled && !outOfRange) return \"continue\";\n\n      [\"startRange\", \"inRange\", \"endRange\", \"notAllowed\"].forEach(function (c) {\n        dayElem.classList.remove(c);\n      });\n      var minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),\n          maxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);\n      elem.classList.add(hoverDate < self.selectedDates[0] ? \"startRange\" : \"endRange\");\n      if (initialDate < hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add(\"startRange\");else if (initialDate > hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add(\"endRange\");\n      if (timestamp >= minRangeDate && timestamp <= maxRangeDate) dayElem.classList.add(\"inRange\");\n    };\n\n    for (var timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0; i < 42; i++, timestamp += self.utils.duration.DAY) {\n      var _ret = _loop(timestamp, i);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n\n  function onResize() {\n    if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();\n  }\n\n  function open(e) {\n    if (self.isMobile) {\n      if (e) {\n        e.preventDefault();\n        e.target.blur();\n      }\n\n      setTimeout(function () {\n        self.mobileInput.click();\n      }, 0);\n      triggerEvent(\"Open\");\n      return;\n    }\n\n    if (self.isOpen || self._input.disabled || self.config.inline) return;\n    self.isOpen = true;\n    self.calendarContainer.classList.add(\"open\");\n    positionCalendar();\n\n    self._input.classList.add(\"active\");\n\n    triggerEvent(\"Open\");\n  }\n\n  function minMaxDateSetter(type) {\n    return function (date) {\n      var dateObj = self.config[\"_\" + type + \"Date\"] = self.parseDate(date);\n      var inverseDateObj = self.config[\"_\" + (type === \"min\" ? \"max\" : \"min\") + \"Date\"];\n      var isValidDate = date && dateObj instanceof Date;\n\n      if (isValidDate) {\n        self[type + \"DateHasTime\"] = dateObj.getHours() || dateObj.getMinutes() || dateObj.getSeconds();\n      }\n\n      if (self.selectedDates) {\n        self.selectedDates = self.selectedDates.filter(function (d) {\n          return isEnabled(d);\n        });\n        if (!self.selectedDates.length && type === \"min\") setHoursFromDate(dateObj);\n        updateValue();\n      }\n\n      if (self.daysContainer) {\n        redraw();\n        if (isValidDate) self.currentYearElement[type] = dateObj.getFullYear();else self.currentYearElement.removeAttribute(type);\n        self.currentYearElement.disabled = inverseDateObj && dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();\n      }\n    };\n  }\n\n  function parseConfig() {\n    var boolOpts = [\"utc\", \"wrap\", \"weekNumbers\", \"allowInput\", \"clickOpens\", \"time_24hr\", \"enableTime\", \"noCalendar\", \"altInput\", \"shorthandCurrentMonth\", \"inline\", \"static\", \"enableSeconds\", \"disableMobile\"];\n    var hooks = [\"onChange\", \"onClose\", \"onDayCreate\", \"onKeyDown\", \"onMonthChange\", \"onOpen\", \"onParseConfig\", \"onReady\", \"onValueUpdate\", \"onYearChange\"];\n    self.config = Object.create(Flatpickr.defaultConfig);\n\n    var userConfig = _extends({}, self.instanceConfig, JSON.parse(JSON.stringify(self.element.dataset || {})));\n\n    self.config.parseDate = userConfig.parseDate;\n    self.config.formatDate = userConfig.formatDate;\n\n    _extends(self.config, userConfig);\n\n    if (!userConfig.dateFormat && userConfig.enableTime) {\n      self.config.dateFormat = self.config.noCalendar ? \"H:i\" + (self.config.enableSeconds ? \":S\" : \"\") : Flatpickr.defaultConfig.dateFormat + \" H:i\" + (self.config.enableSeconds ? \":S\" : \"\");\n    }\n\n    if (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {\n      self.config.altFormat = self.config.noCalendar ? \"h:i\" + (self.config.enableSeconds ? \":S K\" : \" K\") : Flatpickr.defaultConfig.altFormat + (\" h:i\" + (self.config.enableSeconds ? \":S\" : \"\") + \" K\");\n    }\n\n    Object.defineProperty(self.config, \"minDate\", {\n      get: function get() {\n        return this._minDate;\n      },\n      set: minMaxDateSetter(\"min\")\n    });\n    Object.defineProperty(self.config, \"maxDate\", {\n      get: function get() {\n        return this._maxDate;\n      },\n      set: minMaxDateSetter(\"max\")\n    });\n    self.config.minDate = userConfig.minDate;\n    self.config.maxDate = userConfig.maxDate;\n\n    for (var i = 0; i < boolOpts.length; i++) {\n      self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === \"true\";\n    }\n\n    for (var _i = hooks.length; _i--;) {\n      if (self.config[hooks[_i]] !== undefined) {\n        self.config[hooks[_i]] = arrayify(self.config[hooks[_i]] || []).map(bindToInstance);\n      }\n    }\n\n    for (var _i2 = 0; _i2 < self.config.plugins.length; _i2++) {\n      var pluginConf = self.config.plugins[_i2](self) || {};\n\n      for (var key in pluginConf) {\n        if (self.config[key] instanceof Array || ~hooks.indexOf(key)) {\n          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);\n        } else if (typeof userConfig[key] === \"undefined\") self.config[key] = pluginConf[key];\n      }\n    }\n\n    triggerEvent(\"ParseConfig\");\n  }\n\n  function setupLocale() {\n    if (_typeof(self.config.locale) !== \"object\" && typeof Flatpickr.l10ns[self.config.locale] === \"undefined\") console.warn(\"flatpickr: invalid locale \" + self.config.locale);\n    self.l10n = _extends(Object.create(Flatpickr.l10ns.default), _typeof(self.config.locale) === \"object\" ? self.config.locale : self.config.locale !== \"default\" ? Flatpickr.l10ns[self.config.locale] || {} : {});\n  }\n\n  function positionCalendar() {\n    if (self.calendarContainer === undefined) return;\n\n    var calendarHeight = self.calendarContainer.offsetHeight,\n        calendarWidth = self.calendarContainer.offsetWidth,\n        configPos = self.config.position,\n        inputBounds = self._positionElement.getBoundingClientRect(),\n        distanceFromBottom = window.innerHeight - inputBounds.bottom,\n        showOnTop = configPos === \"above\" || configPos !== \"below\" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;\n\n    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? self._positionElement.offsetHeight + 2 : -calendarHeight - 2);\n    toggleClass(self.calendarContainer, \"arrowTop\", !showOnTop);\n    toggleClass(self.calendarContainer, \"arrowBottom\", showOnTop);\n    if (self.config.inline) return;\n    var left = window.pageXOffset + inputBounds.left;\n    var right = window.document.body.offsetWidth - inputBounds.right;\n    var rightMost = left + calendarWidth > window.document.body.offsetWidth;\n    toggleClass(self.calendarContainer, \"rightMost\", rightMost);\n    if (self.config.static) return;\n    self.calendarContainer.style.top = top + \"px\";\n\n    if (!rightMost) {\n      self.calendarContainer.style.left = left + \"px\";\n      self.calendarContainer.style.right = \"auto\";\n    } else {\n      self.calendarContainer.style.left = \"auto\";\n      self.calendarContainer.style.right = right + \"px\";\n    }\n  }\n\n  function redraw() {\n    if (self.config.noCalendar || self.isMobile) return;\n    buildWeekdays();\n    updateNavigationCurrentMonth();\n    buildDays();\n  }\n\n  function selectDate(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    if (!e.target.classList.contains(\"flatpickr-day\") || e.target.classList.contains(\"disabled\") || e.target.classList.contains(\"notAllowed\")) return;\n    var selectedDate = self.latestSelectedDateObj = new Date(e.target.dateObj.getTime());\n    var shouldChangeMonth = selectedDate.getMonth() !== self.currentMonth && self.config.mode !== \"range\";\n    self.selectedDateElem = e.target;\n    if (self.config.mode === \"single\") self.selectedDates = [selectedDate];else if (self.config.mode === \"multiple\") {\n      var selectedIndex = isDateSelected(selectedDate);\n      if (selectedIndex) self.selectedDates.splice(selectedIndex, 1);else self.selectedDates.push(selectedDate);\n    } else if (self.config.mode === \"range\") {\n      if (self.selectedDates.length === 2) self.clear();\n      self.selectedDates.push(selectedDate); // unless selecting same date twice, sort ascendingly\n\n      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {\n        return a.getTime() - b.getTime();\n      });\n    }\n    setHoursFromInputs();\n\n    if (shouldChangeMonth) {\n      var isNewYear = self.currentYear !== selectedDate.getFullYear();\n      self.currentYear = selectedDate.getFullYear();\n      self.currentMonth = selectedDate.getMonth();\n      if (isNewYear) triggerEvent(\"YearChange\");\n      triggerEvent(\"MonthChange\");\n    }\n\n    buildDays();\n    if (self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);\n    updateValue();\n    if (self.config.enableTime) setTimeout(function () {\n      return self.showTimeInput = true;\n    }, 50);\n\n    if (self.config.mode === \"range\") {\n      if (self.selectedDates.length === 1) {\n        onMouseOver(e.target);\n        self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > self.days.childNodes[0].dateObj;\n        self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);\n      } else updateNavigationCurrentMonth();\n    }\n\n    triggerEvent(\"Change\"); // maintain focus\n\n    if (!shouldChangeMonth) focusOnDay(e.target.$i, 0);else afterDayAnim(function () {\n      return self.selectedDateElem.focus();\n    });\n    if (self.config.enableTime) setTimeout(function () {\n      return self.hourElement.select();\n    }, 451);\n\n    if (self.config.closeOnSelect) {\n      var single = self.config.mode === \"single\" && !self.config.enableTime;\n      var range = self.config.mode === \"range\" && self.selectedDates.length === 2 && !self.config.enableTime;\n      if (single || range) self.close();\n    }\n  }\n\n  function set(option, value) {\n    self.config[option] = value;\n    self.redraw();\n    jumpToDate();\n  }\n\n  function setSelectedDate(inputDate, format) {\n    if (inputDate instanceof Array) self.selectedDates = inputDate.map(function (d) {\n      return self.parseDate(d, format);\n    });else if (inputDate instanceof Date || !isNaN(inputDate)) self.selectedDates = [self.parseDate(inputDate, format)];else if (inputDate && inputDate.substring) {\n      switch (self.config.mode) {\n        case \"single\":\n          self.selectedDates = [self.parseDate(inputDate, format)];\n          break;\n\n        case \"multiple\":\n          self.selectedDates = inputDate.split(\"; \").map(function (date) {\n            return self.parseDate(date, format);\n          });\n          break;\n\n        case \"range\":\n          self.selectedDates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {\n            return self.parseDate(date, format);\n          });\n          break;\n\n        default:\n          break;\n      }\n    }\n    self.selectedDates = self.selectedDates.filter(function (d) {\n      return d instanceof Date && isEnabled(d, false);\n    });\n    self.selectedDates.sort(function (a, b) {\n      return a.getTime() - b.getTime();\n    });\n  }\n\n  function setDate(date, triggerChange, format) {\n    if (!date) return self.clear(triggerChange);\n    setSelectedDate(date, format);\n    self.showTimeInput = self.selectedDates.length > 0;\n    self.latestSelectedDateObj = self.selectedDates[0];\n    self.redraw();\n    jumpToDate();\n    setHoursFromDate();\n    updateValue(triggerChange);\n    if (triggerChange) triggerEvent(\"Change\");\n  }\n\n  function setupDates() {\n    function parseDateRules(arr) {\n      for (var i = arr.length; i--;) {\n        if (typeof arr[i] === \"string\" || +arr[i]) arr[i] = self.parseDate(arr[i], null, true);else if (arr[i] && arr[i].from && arr[i].to) {\n          arr[i].from = self.parseDate(arr[i].from);\n          arr[i].to = self.parseDate(arr[i].to);\n        }\n      }\n\n      return arr.filter(function (x) {\n        return x;\n      }); // remove falsy values\n    }\n\n    self.selectedDates = [];\n    self.now = new Date();\n    if (self.config.disable.length) self.config.disable = parseDateRules(self.config.disable);\n    if (self.config.enable.length) self.config.enable = parseDateRules(self.config.enable);\n    var preloadedDate = self.config.defaultDate || self.input.value;\n    if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);\n    var initialDate = self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now ? self.config.maxDate : self.now;\n    self.currentYear = initialDate.getFullYear();\n    self.currentMonth = initialDate.getMonth();\n    if (self.selectedDates.length) self.latestSelectedDateObj = self.selectedDates[0];\n    self.minDateHasTime = self.config.minDate && (self.config.minDate.getHours() || self.config.minDate.getMinutes() || self.config.minDate.getSeconds());\n    self.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours() || self.config.maxDate.getMinutes() || self.config.maxDate.getSeconds());\n    Object.defineProperty(self, \"latestSelectedDateObj\", {\n      get: function get() {\n        return self._selectedDateObj || self.selectedDates[self.selectedDates.length - 1];\n      },\n      set: function set(date) {\n        self._selectedDateObj = date;\n      }\n    });\n\n    if (!self.isMobile) {\n      Object.defineProperty(self, \"showTimeInput\", {\n        get: function get() {\n          return self._showTimeInput;\n        },\n        set: function set(bool) {\n          self._showTimeInput = bool;\n          if (self.calendarContainer) toggleClass(self.calendarContainer, \"showTimeInput\", bool);\n          positionCalendar();\n        }\n      });\n    }\n  }\n\n  function setupHelperFunctions() {\n    self.utils = {\n      duration: {\n        DAY: 86400000\n      },\n      getDaysinMonth: function getDaysinMonth(month, yr) {\n        month = typeof month === \"undefined\" ? self.currentMonth : month;\n        yr = typeof yr === \"undefined\" ? self.currentYear : yr;\n        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;\n        return self.l10n.daysInMonth[month];\n      },\n      monthToStr: function monthToStr(monthNumber, shorthand) {\n        shorthand = typeof shorthand === \"undefined\" ? self.config.shorthandCurrentMonth : shorthand;\n        return self.l10n.months[(shorthand ? \"short\" : \"long\") + \"hand\"][monthNumber];\n      }\n    };\n  }\n  /* istanbul ignore next */\n\n\n  function setupFormats() {\n    [\"D\", \"F\", \"J\", \"M\", \"W\", \"l\"].forEach(function (f) {\n      self.formats[f] = Flatpickr.prototype.formats[f].bind(self);\n    });\n    self.revFormat.F = Flatpickr.prototype.revFormat.F.bind(self);\n    self.revFormat.M = Flatpickr.prototype.revFormat.M.bind(self);\n  }\n\n  function setupInputs() {\n    self.input = self.config.wrap ? self.element.querySelector(\"[data-input]\") : self.element;\n    /* istanbul ignore next */\n\n    if (!self.input) return console.warn(\"Error: invalid input element specified\", self.input);\n    self.input._type = self.input.type;\n    self.input.type = \"text\";\n    self.input.classList.add(\"flatpickr-input\");\n    self._input = self.input;\n\n    if (self.config.altInput) {\n      // replicate self.element\n      self.altInput = createElement(self.input.nodeName, self.input.className + \" \" + self.config.altInputClass);\n      self._input = self.altInput;\n      self.altInput.placeholder = self.input.placeholder;\n      self.altInput.disabled = self.input.disabled;\n      self.altInput.type = \"text\";\n      self.input.type = \"hidden\";\n      if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);\n    }\n\n    if (!self.config.allowInput) self._input.setAttribute(\"readonly\", \"readonly\");\n    self._positionElement = self.config.positionElement || self._input;\n  }\n\n  function setupMobile() {\n    var inputType = self.config.enableTime ? self.config.noCalendar ? \"time\" : \"datetime-local\" : \"date\";\n    self.mobileInput = createElement(\"input\", self.input.className + \" flatpickr-mobile\");\n    self.mobileInput.step = \"any\";\n    self.mobileInput.tabIndex = 1;\n    self.mobileInput.type = inputType;\n    self.mobileInput.disabled = self.input.disabled;\n    self.mobileInput.placeholder = self.input.placeholder;\n    self.mobileFormatStr = inputType === \"datetime-local\" ? \"Y-m-d\\\\TH:i:S\" : inputType === \"date\" ? \"Y-m-d\" : \"H:i:S\";\n\n    if (self.selectedDates.length) {\n      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);\n    }\n\n    if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, \"Y-m-d\");\n    if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, \"Y-m-d\");\n    self.input.type = \"hidden\";\n    if (self.config.altInput) self.altInput.type = \"hidden\";\n\n    try {\n      self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);\n    } catch (e) {//\n    }\n\n    self.mobileInput.addEventListener(\"change\", function (e) {\n      self.setDate(e.target.value, false, self.mobileFormatStr);\n      triggerEvent(\"Change\");\n      triggerEvent(\"Close\");\n    });\n  }\n\n  function toggle() {\n    if (self.isOpen) return self.close();\n    self.open();\n  }\n\n  function triggerEvent(event, data) {\n    var hooks = self.config[\"on\" + event];\n\n    if (hooks !== undefined && hooks.length > 0) {\n      for (var i = 0; hooks[i] && i < hooks.length; i++) {\n        hooks[i](self.selectedDates, self.input.value, self, data);\n      }\n    }\n\n    if (event === \"Change\") {\n      self.input.dispatchEvent(createEvent(\"change\")); // many front-end frameworks bind to the input event\n\n      self.input.dispatchEvent(createEvent(\"input\"));\n    }\n  }\n  /**\n   * Creates an Event, normalized across browsers\n   * @param {String} name the event name, e.g. \"click\"\n   * @return {Event} the created event\n   */\n\n\n  function createEvent(name) {\n    if (self._supportsEvents) return new Event(name, {\n      bubbles: true\n    });\n    self._[name + \"Event\"] = document.createEvent(\"Event\");\n\n    self._[name + \"Event\"].initEvent(name, true, true);\n\n    return self._[name + \"Event\"];\n  }\n\n  function isDateSelected(date) {\n    for (var i = 0; i < self.selectedDates.length; i++) {\n      if (compareDates(self.selectedDates[i], date) === 0) return \"\" + i;\n    }\n\n    return false;\n  }\n\n  function isDateInRange(date) {\n    if (self.config.mode !== \"range\" || self.selectedDates.length < 2) return false;\n    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;\n  }\n\n  function updateNavigationCurrentMonth() {\n    if (self.config.noCalendar || self.isMobile || !self.monthNav) return;\n    self.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + \" \";\n    self.currentYearElement.value = self.currentYear;\n    self._hidePrevMonthArrow = self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());\n    self._hideNextMonthArrow = self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());\n  }\n  /**\n   * Updates the values of inputs associated with the calendar\n   * @return {void}\n   */\n\n\n  function updateValue(triggerChange) {\n    if (!self.selectedDates.length) return self.clear(triggerChange);\n\n    if (self.isMobile) {\n      self.mobileInput.value = self.selectedDates.length ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : \"\";\n    }\n\n    var joinChar = self.config.mode !== \"range\" ? \"; \" : self.l10n.rangeSeparator;\n    self.input.value = self.selectedDates.map(function (dObj) {\n      return self.formatDate(dObj, self.config.dateFormat);\n    }).join(joinChar);\n\n    if (self.config.altInput) {\n      self.altInput.value = self.selectedDates.map(function (dObj) {\n        return self.formatDate(dObj, self.config.altFormat);\n      }).join(joinChar);\n    }\n\n    triggerEvent(\"ValueUpdate\");\n  }\n\n  function mouseDelta(e) {\n    return Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY));\n  }\n\n  function onMonthNavScroll(e) {\n    e.preventDefault();\n    var isYear = self.currentYearElement.parentNode.contains(e.target);\n\n    if (e.target === self.currentMonthElement || isYear) {\n      var delta = mouseDelta(e);\n\n      if (isYear) {\n        changeYear(self.currentYear + delta);\n        e.target.value = self.currentYear;\n      } else self.changeMonth(delta, true, false);\n    }\n  }\n\n  function onMonthNavClick(e) {\n    var isPrevMonth = self.prevMonthNav.contains(e.target);\n    var isNextMonth = self.nextMonthNav.contains(e.target);\n    if (isPrevMonth || isNextMonth) changeMonth(isPrevMonth ? -1 : 1);else if (e.target === self.currentYearElement) {\n      e.preventDefault();\n      self.currentYearElement.select();\n    } else if (e.target.className === \"arrowUp\") self.changeYear(self.currentYear + 1);else if (e.target.className === \"arrowDown\") self.changeYear(self.currentYear - 1);\n  }\n  /**\n   * Creates an HTMLElement with given tag, class, and textual content\n   * @param {String} tag the HTML tag\n   * @param {String} className the new element's class name\n   * @param {String} content The new element's text content\n   * @return {HTMLElement} the created HTML element\n   */\n\n\n  function createElement(tag, className, content) {\n    var e = window.document.createElement(tag);\n    className = className || \"\";\n    content = content || \"\";\n    e.className = className;\n    if (content !== undefined) e.textContent = content;\n    return e;\n  }\n\n  function arrayify(obj) {\n    if (obj instanceof Array) return obj;\n    return [obj];\n  }\n\n  function toggleClass(elem, className, bool) {\n    if (bool) return elem.classList.add(className);\n    elem.classList.remove(className);\n  }\n  /* istanbul ignore next */\n\n\n  function debounce(func, wait, immediate) {\n    var timeout = void 0;\n    return function () {\n      var context = this,\n          args = arguments;\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      }, wait);\n      if (immediate && !timeout) func.apply(context, args);\n    };\n  }\n  /**\n   * Compute the difference in dates, measured in ms\n   * @param {Date} date1\n   * @param {Date} date2\n   * @param {Boolean} timeless whether to reset times of both dates to 00:00\n   * @return {Number} the difference in ms\n   */\n\n\n  function compareDates(date1, date2, timeless) {\n    if (!(date1 instanceof Date) || !(date2 instanceof Date)) return false;\n\n    if (timeless !== false) {\n      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);\n    }\n\n    return date1.getTime() - date2.getTime();\n  }\n\n  function timeWrapper(e) {\n    e.preventDefault();\n    var isKeyDown = e.type === \"keydown\",\n        isWheel = e.type === \"wheel\",\n        isIncrement = e.type === \"increment\",\n        input = e.target;\n    if (self.amPM && e.target === self.amPM) return e.target.textContent = [\"AM\", \"PM\"][e.target.textContent === \"AM\" | 0];\n    var min = Number(input.min),\n        max = Number(input.max),\n        step = Number(input.step),\n        curValue = parseInt(input.value, 10),\n        delta = e.delta || (!isKeyDown ? Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY)) || 0 : e.which === 38 ? 1 : -1);\n    var newValue = curValue + step * delta;\n\n    if (typeof input.value !== \"undefined\" && input.value.length === 2) {\n      var isHourElem = input === self.hourElement,\n          isMinuteElem = input === self.minuteElement;\n\n      if (newValue < min) {\n        newValue = max + newValue + !isHourElem + (isHourElem && !self.amPM);\n        if (isMinuteElem) incrementNumInput(null, -1, self.hourElement);\n      } else if (newValue > max) {\n        newValue = input === self.hourElement ? newValue - max - !self.amPM : min;\n        if (isMinuteElem) incrementNumInput(null, 1, self.hourElement);\n      }\n\n      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.amPM.textContent === \"PM\" ? \"AM\" : \"PM\";\n      input.value = self.pad(newValue);\n    }\n  }\n\n  init();\n  return self;\n}\n/* istanbul ignore next */\n\n\nFlatpickr.defaultConfig = {\n  mode: \"single\",\n  position: \"auto\",\n  animate: window.navigator.userAgent.indexOf(\"MSIE\") === -1,\n\n  /* if true, dates will be parsed, formatted, and displayed in UTC.\n  preloading date strings w/ timezones is recommended but not necessary */\n  utc: false,\n  // wrap: see https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements\n  wrap: false,\n  // enables week numbers\n  weekNumbers: false,\n  // allow manual datetime input\n  allowInput: false,\n\n  /*\n  \tclicking on input opens the date(time)picker.\n  \tdisable if you wish to open the calendar manually with .open()\n  */\n  clickOpens: true,\n\n  /*\n  \tcloses calendar after date selection,\n  \tunless 'mode' is 'multiple' or enableTime is true\n  */\n  closeOnSelect: true,\n  // display time picker in 24 hour mode\n  time_24hr: false,\n  // enables the time picker functionality\n  enableTime: false,\n  // noCalendar: true will hide the calendar. use for a time picker along w/ enableTime\n  noCalendar: false,\n  // more date format chars at https://chmln.github.io/flatpickr/#dateformat\n  dateFormat: \"Y-m-d\",\n  // date format used in aria-label for days\n  ariaDateFormat: \"F j, Y\",\n  // altInput - see https://chmln.github.io/flatpickr/#altinput\n  altInput: false,\n  // the created altInput element will have this class.\n  altInputClass: \"form-control input\",\n  // same as dateFormat, but for altInput\n  altFormat: \"F j, Y\",\n  // defaults to e.g. June 10, 2016\n  // defaultDate - either a datestring or a date object. used for datetimepicker\"s initial value\n  defaultDate: null,\n  // the minimum date that user can pick (inclusive)\n  minDate: null,\n  // the maximum date that user can pick (inclusive)\n  maxDate: null,\n  // dateparser that transforms a given string to a date object\n  parseDate: null,\n  // dateformatter that transforms a given date object to a string, according to passed format\n  formatDate: null,\n  getWeek: function getWeek(givenDate) {\n    var date = new Date(givenDate.getTime());\n    var onejan = new Date(date.getFullYear(), 0, 1);\n    return Math.ceil(((date - onejan) / 86400000 + onejan.getDay() + 1) / 7);\n  },\n  // see https://chmln.github.io/flatpickr/#disable\n  enable: [],\n  // see https://chmln.github.io/flatpickr/#disable\n  disable: [],\n  // display the short version of month names - e.g. Sep instead of September\n  shorthandCurrentMonth: false,\n  // displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar\n  inline: false,\n  // position calendar inside wrapper and next to the input element\n  // leave at false unless you know what you\"re doing\n  \"static\": false,\n  // DOM node to append the calendar to in *static* mode\n  appendTo: null,\n  // code for previous/next icons. this is where you put your custom icon code e.g. fontawesome\n  prevArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>\",\n  nextArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>\",\n  // enables seconds in the time picker\n  enableSeconds: false,\n  // step size used when scrolling/incrementing the hour element\n  hourIncrement: 1,\n  // step size used when scrolling/incrementing the minute element\n  minuteIncrement: 5,\n  // initial value in the hour element\n  defaultHour: 12,\n  // initial value in the minute element\n  defaultMinute: 0,\n  // disable native mobile datetime input support\n  disableMobile: false,\n  // default locale\n  locale: \"default\",\n  plugins: [],\n  // called every time calendar is closed\n  onClose: undefined,\n  // function (dateObj, dateStr) {}\n  // onChange callback when user selects a date or time\n  onChange: undefined,\n  // function (dateObj, dateStr) {}\n  // called for every day element\n  onDayCreate: undefined,\n  // called every time the month is changed\n  onMonthChange: undefined,\n  // called every time calendar is opened\n  onOpen: undefined,\n  // function (dateObj, dateStr) {}\n  // called after the configuration has been parsed\n  onParseConfig: undefined,\n  // called after calendar is ready\n  onReady: undefined,\n  // function (dateObj, dateStr) {}\n  // called after input value updated\n  onValueUpdate: undefined,\n  // called every time the year is changed\n  onYearChange: undefined,\n  onKeyDown: undefined\n};\n/* istanbul ignore next */\n\nFlatpickr.l10ns = {\n  en: {\n    weekdays: {\n      shorthand: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n      longhand: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    },\n    months: {\n      shorthand: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n      longhand: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n    },\n    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    firstDayOfWeek: 0,\n    ordinal: function ordinal(nth) {\n      var s = nth % 100;\n      if (s > 3 && s < 21) return \"th\";\n\n      switch (s % 10) {\n        case 1:\n          return \"st\";\n\n        case 2:\n          return \"nd\";\n\n        case 3:\n          return \"rd\";\n\n        default:\n          return \"th\";\n      }\n    },\n    rangeSeparator: \" to \",\n    weekAbbreviation: \"Wk\",\n    scrollTitle: \"Scroll to increment\",\n    toggleTitle: \"Click to toggle\"\n  }\n};\nFlatpickr.l10ns.default = Object.create(Flatpickr.l10ns.en);\n\nFlatpickr.localize = function (l10n) {\n  return _extends(Flatpickr.l10ns.default, l10n || {});\n};\n\nFlatpickr.setDefaults = function (config) {\n  return _extends(Flatpickr.defaultConfig, config || {});\n};\n\nFlatpickr.prototype = {\n  formats: {\n    // get the date in UTC\n    Z: function Z(date) {\n      return date.toISOString();\n    },\n    // weekday name, short, e.g. Thu\n    D: function D(date) {\n      return this.l10n.weekdays.shorthand[this.formats.w(date)];\n    },\n    // full month name e.g. January\n    F: function F(date) {\n      return this.utils.monthToStr(this.formats.n(date) - 1, false);\n    },\n    // padded hour 1-12\n    G: function G(date) {\n      return Flatpickr.prototype.pad(Flatpickr.prototype.formats.h(date));\n    },\n    // hours with leading zero e.g. 03\n    H: function H(date) {\n      return Flatpickr.prototype.pad(date.getHours());\n    },\n    // day (1-30) with ordinal suffix e.g. 1st, 2nd\n    J: function J(date) {\n      return date.getDate() + this.l10n.ordinal(date.getDate());\n    },\n    // AM/PM\n    K: function K(date) {\n      return date.getHours() > 11 ? \"PM\" : \"AM\";\n    },\n    // shorthand month e.g. Jan, Sep, Oct, etc\n    M: function M(date) {\n      return this.utils.monthToStr(date.getMonth(), true);\n    },\n    // seconds 00-59\n    S: function S(date) {\n      return Flatpickr.prototype.pad(date.getSeconds());\n    },\n    // unix timestamp\n    U: function U(date) {\n      return date.getTime() / 1000;\n    },\n    W: function W(date) {\n      return this.config.getWeek(date);\n    },\n    // full year e.g. 2016\n    Y: function Y(date) {\n      return date.getFullYear();\n    },\n    // day in month, padded (01-30)\n    d: function d(date) {\n      return Flatpickr.prototype.pad(date.getDate());\n    },\n    // hour from 1-12 (am/pm)\n    h: function h(date) {\n      return date.getHours() % 12 ? date.getHours() % 12 : 12;\n    },\n    // minutes, padded with leading zero e.g. 09\n    i: function i(date) {\n      return Flatpickr.prototype.pad(date.getMinutes());\n    },\n    // day in month (1-30)\n    j: function j(date) {\n      return date.getDate();\n    },\n    // weekday name, full, e.g. Thursday\n    l: function l(date) {\n      return this.l10n.weekdays.longhand[date.getDay()];\n    },\n    // padded month number (01-12)\n    m: function m(date) {\n      return Flatpickr.prototype.pad(date.getMonth() + 1);\n    },\n    // the month number (1-12)\n    n: function n(date) {\n      return date.getMonth() + 1;\n    },\n    // seconds 0-59\n    s: function s(date) {\n      return date.getSeconds();\n    },\n    // number of the day of the week\n    w: function w(date) {\n      return date.getDay();\n    },\n    // last two digits of year e.g. 16 for 2016\n    y: function y(date) {\n      return String(date.getFullYear()).substring(2);\n    }\n  },\n\n  /**\n   * Formats a given Date object into a string based on supplied format\n   * @param {Date} dateObj the date object\n   * @param {String} frmt a string composed of formatting tokens e.g. \"Y-m-d\"\n   * @return {String} The textual representation of the date e.g. 2017-02-03\n   */\n  formatDate: function formatDate(dateObj, frmt) {\n    var _this = this;\n\n    if (this.config !== undefined && this.config.formatDate !== undefined) return this.config.formatDate(dateObj, frmt);\n    return frmt.split(\"\").map(function (c, i, arr) {\n      return _this.formats[c] && arr[i - 1] !== \"\\\\\" ? _this.formats[c](dateObj) : c !== \"\\\\\" ? c : \"\";\n    }).join(\"\");\n  },\n  revFormat: {\n    D: function D() {},\n    F: function F(dateObj, monthName) {\n      dateObj.setMonth(this.l10n.months.longhand.indexOf(monthName));\n    },\n    G: function G(dateObj, hour) {\n      dateObj.setHours(parseFloat(hour));\n    },\n    H: function H(dateObj, hour) {\n      dateObj.setHours(parseFloat(hour));\n    },\n    J: function J(dateObj, day) {\n      dateObj.setDate(parseFloat(day));\n    },\n    K: function K(dateObj, amPM) {\n      var hours = dateObj.getHours();\n      if (hours !== 12) dateObj.setHours(hours % 12 + 12 * /pm/i.test(amPM));\n    },\n    M: function M(dateObj, shortMonth) {\n      dateObj.setMonth(this.l10n.months.shorthand.indexOf(shortMonth));\n    },\n    S: function S(dateObj, seconds) {\n      dateObj.setSeconds(seconds);\n    },\n    U: function U(dateObj, unixSeconds) {\n      return new Date(parseFloat(unixSeconds) * 1000);\n    },\n    W: function W(dateObj, weekNumber) {\n      weekNumber = parseInt(weekNumber);\n      return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0, 0);\n    },\n    Y: function Y(dateObj, year) {\n      dateObj.setFullYear(year);\n    },\n    Z: function Z(dateObj, ISODate) {\n      return new Date(ISODate);\n    },\n    d: function d(dateObj, day) {\n      dateObj.setDate(parseFloat(day));\n    },\n    h: function h(dateObj, hour) {\n      dateObj.setHours(parseFloat(hour));\n    },\n    i: function i(dateObj, minutes) {\n      dateObj.setMinutes(parseFloat(minutes));\n    },\n    j: function j(dateObj, day) {\n      dateObj.setDate(parseFloat(day));\n    },\n    l: function l() {},\n    m: function m(dateObj, month) {\n      dateObj.setMonth(parseFloat(month) - 1);\n    },\n    n: function n(dateObj, month) {\n      dateObj.setMonth(parseFloat(month) - 1);\n    },\n    s: function s(dateObj, seconds) {\n      dateObj.setSeconds(parseFloat(seconds));\n    },\n    w: function w() {},\n    y: function y(dateObj, year) {\n      dateObj.setFullYear(2000 + parseFloat(year));\n    }\n  },\n  tokenRegex: {\n    D: \"(\\\\w+)\",\n    F: \"(\\\\w+)\",\n    G: \"(\\\\d\\\\d|\\\\d)\",\n    H: \"(\\\\d\\\\d|\\\\d)\",\n    J: \"(\\\\d\\\\d|\\\\d)\\\\w+\",\n    K: \"(\\\\w+)\",\n    M: \"(\\\\w+)\",\n    S: \"(\\\\d\\\\d|\\\\d)\",\n    U: \"(.+)\",\n    W: \"(\\\\d\\\\d|\\\\d)\",\n    Y: \"(\\\\d{4})\",\n    Z: \"(.+)\",\n    d: \"(\\\\d\\\\d|\\\\d)\",\n    h: \"(\\\\d\\\\d|\\\\d)\",\n    i: \"(\\\\d\\\\d|\\\\d)\",\n    j: \"(\\\\d\\\\d|\\\\d)\",\n    l: \"(\\\\w+)\",\n    m: \"(\\\\d\\\\d|\\\\d)\",\n    n: \"(\\\\d\\\\d|\\\\d)\",\n    s: \"(\\\\d\\\\d|\\\\d)\",\n    w: \"(\\\\d\\\\d|\\\\d)\",\n    y: \"(\\\\d{2})\"\n  },\n  pad: function pad(number) {\n    return (\"0\" + number).slice(-2);\n  },\n\n  /**\n   * Parses a date(+time) string into a Date object\n   * @param {String} date the date string, e.g. 2017-02-03 14:45\n   * @param {String} givenFormat the date format, e.g. Y-m-d H:i\n   * @param {Boolean} timeless whether to reset the time of Date object\n   * @return {Date} the parsed Date object\n   */\n  parseDate: function parseDate(date, givenFormat, timeless) {\n    if (!date) return null;\n    var date_orig = date;\n\n    if (date instanceof Date) {\n      date = new Date(date.getTime()); // create a copy\n\n      date.fp_isUTC = date_orig.fp_isUTC;\n    } else if (date.toFixed !== undefined) // timestamp\n      date = new Date(date);else {\n      // date string\n      var format = givenFormat || (this.config || Flatpickr.defaultConfig).dateFormat;\n      date = String(date).trim();\n\n      if (date === \"today\") {\n        date = new Date();\n        timeless = true;\n      } else if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone\n        date = new Date(date);else if (this.config && this.config.parseDate) date = this.config.parseDate(date, format);else {\n        var parsedDate = !this.config || !this.config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));\n        var matched = void 0;\n\n        for (var i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n          var token = format[i];\n          var isBackSlash = token === \"\\\\\";\n          var escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n\n          if (this.tokenRegex[token] && !escaped) {\n            regexStr += this.tokenRegex[token];\n            var match = new RegExp(regexStr).exec(date);\n\n            if (match && (matched = true)) {\n              parsedDate = this.revFormat[token](parsedDate, match[++matchIndex]) || parsedDate;\n            }\n          } else if (!isBackSlash) regexStr += \".\"; // don't really care\n\n        }\n\n        date = matched ? parsedDate : null;\n      }\n    }\n    /* istanbul ignore next */\n\n\n    if (!(date instanceof Date)) {\n      console.warn(\"flatpickr: invalid date \" + date_orig);\n      console.info(this.element);\n      return null;\n    }\n\n    if (this.config && this.config.utc && !date.fp_isUTC) date = date.fp_toUTC();\n    if (timeless === true) date.setHours(0, 0, 0, 0);\n    return date;\n  }\n};\n/* istanbul ignore next */\n\nfunction _flatpickr(nodeList, config) {\n  var nodes = Array.prototype.slice.call(nodeList); // static list\n\n  var instances = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    try {\n      nodes[i]._flatpickr = new Flatpickr(nodes[i], config || {});\n      instances.push(nodes[i]._flatpickr);\n    } catch (e) {\n      console.warn(e, e.stack);\n    }\n  }\n\n  return instances.length === 1 ? instances[0] : instances;\n}\n/* istanbul ignore next */\n\n\nif (typeof HTMLElement !== \"undefined\") {\n  // browser env\n  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {\n    return _flatpickr(this, config);\n  };\n\n  HTMLElement.prototype.flatpickr = function (config) {\n    return _flatpickr([this], config);\n  };\n}\n/* istanbul ignore next */\n\n\nfunction flatpickr(selector, config) {\n  return _flatpickr(window.document.querySelectorAll(selector), config);\n}\n/* istanbul ignore next */\n\n\nif (typeof jQuery !== \"undefined\") {\n  jQuery.fn.flatpickr = function (config) {\n    return _flatpickr(this, config);\n  };\n}\n\nDate.prototype.fp_incr = function (days) {\n  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + parseInt(days, 10));\n};\n\nDate.prototype.fp_isUTC = false;\n\nDate.prototype.fp_toUTC = function () {\n  var newDate = new Date(this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds());\n  newDate.fp_isUTC = true;\n  return newDate;\n};\n\nif (typeof module !== \"undefined\") module.exports = Flatpickr;","map":null,"metadata":{},"sourceType":"script"}