{"ast":null,"code":"import _classCallCheck from \"/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport eventMatches from '../misc/event-matches';\nimport on from '../misc/on';\nexport default function (ToMix) {\n  /**\n   * Mix-in class to instantiate components upon events.\n   * @class InitComponentByEvent\n   */\n  var InitComponentByEvent =\n  /*#__PURE__*/\n  function (_ToMix) {\n    _inherits(InitComponentByEvent, _ToMix);\n\n    function InitComponentByEvent() {\n      _classCallCheck(this, InitComponentByEvent);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(InitComponentByEvent).apply(this, arguments));\n    }\n\n    _createClass(InitComponentByEvent, null, [{\n      key: \"init\",\n\n      /**\n       * `true` suggests that this component is lazily initialized upon an action/event, etc.\n       * @type {boolean}\n       */\n\n      /**\n       * Instantiates this component in the given element.\n       * If the given element indicates that it's an component of this class, instantiates it.\n       * Otherwise, instantiates this component by clicking on this component in the given node.\n       * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.\n       * @param {Object} [options] The component options.\n       * @param {string} [options.selectorInit] The CSS selector to find this component.\n       * @returns {Handle} The handle to remove the event listener to handle clicking.\n       */\n      value: function init() {\n        var _this = this;\n\n        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var effectiveOptions = Object.assign(Object.create(this.options), options);\n\n        if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {\n          throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');\n        }\n\n        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {\n          this.create(target, options);\n        } else {\n          // To work around non-bubbling `focus` event, use `focusin` event instead of it's available, and \"capture mode\" otherwise\n          var hasFocusin = 'onfocusin' in (target.nodeType === Node.ELEMENT_NODE ? target.ownerDocument : target).defaultView;\n          var handles = effectiveOptions.initEventNames.map(function (name) {\n            var eventName = name === 'focus' && hasFocusin ? 'focusin' : name;\n            return on(target, eventName, function (event) {\n              var element = eventMatches(event, effectiveOptions.selectorInit); // Instantiated components handles events by themselves\n\n              if (element && !_this.components.has(element)) {\n                var component = _this.create(element, options);\n\n                if (typeof component.createdByEvent === 'function') {\n                  component.createdByEvent(event);\n                }\n              }\n            }, name === 'focus' && !hasFocusin);\n          });\n          return {\n            release: function release() {\n              for (var handle = handles.pop(); handle; handle = handles.pop()) {\n                handle.release();\n              }\n            }\n          };\n        }\n\n        return '';\n      }\n    }]);\n\n    return InitComponentByEvent;\n  }(ToMix);\n\n  InitComponentByEvent.forLazyInit = true;\n  return InitComponentByEvent;\n}","map":{"version":3,"sources":["/Users/tatianamoreira/Documents/testTech/react/carbon-design-react-test/src/globals/js/mixins/init-component-by-event.js"],"names":["eventMatches","on","ToMix","InitComponentByEvent","target","document","options","effectiveOptions","Object","assign","create","nodeType","Node","ELEMENT_NODE","DOCUMENT_NODE","TypeError","matches","selectorInit","hasFocusin","ownerDocument","defaultView","handles","initEventNames","map","name","eventName","event","element","components","has","component","createdByEvent","release","handle","pop","forLazyInit"],"mappings":";;;;;AAAA,OAAOA,YAAP,MAAyB,uBAAzB;AACA,OAAOC,EAAP,MAAe,YAAf;AAEA,eAAe,UAASC,KAAT,EAAgB;AAC7B;;;;AAD6B,MAKvBC,oBALuB;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAM3B;;;;;AAMA;;;;;;;;;AAZ2B,6BAqBkB;AAAA;;AAAA,YAAjCC,MAAiC,uEAAxBC,QAAwB;AAAA,YAAdC,OAAc,uEAAJ,EAAI;AAC3C,YAAMC,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,MAAP,CAAc,KAAKJ,OAAnB,CAAd,EAA2CA,OAA3C,CAAzB;;AACA,YAAI,CAACF,MAAD,IAAYA,MAAM,CAACO,QAAP,KAAoBC,IAAI,CAACC,YAAzB,IAAyCT,MAAM,CAACO,QAAP,KAAoBC,IAAI,CAACE,aAAlF,EAAkG;AAChG,gBAAM,IAAIC,SAAJ,CAAc,uFAAd,CAAN;AACD;;AACD,YAAIX,MAAM,CAACO,QAAP,KAAoBC,IAAI,CAACC,YAAzB,IAAyCT,MAAM,CAACY,OAAP,CAAeT,gBAAgB,CAACU,YAAhC,CAA7C,EAA4F;AAC1F,eAAKP,MAAL,CAAYN,MAAZ,EAAoBE,OAApB;AACD,SAFD,MAEO;AACL;AACA,cAAMY,UAAU,GAAG,eAAe,CAACd,MAAM,CAACO,QAAP,KAAoBC,IAAI,CAACC,YAAzB,GAAwCT,MAAM,CAACe,aAA/C,GAA+Df,MAAhE,EAAwEgB,WAA1G;AACA,cAAMC,OAAO,GAAGd,gBAAgB,CAACe,cAAjB,CAAgCC,GAAhC,CAAoC,UAAAC,IAAI,EAAI;AAC1D,gBAAMC,SAAS,GAAGD,IAAI,KAAK,OAAT,IAAoBN,UAApB,GAAiC,SAAjC,GAA6CM,IAA/D;AACA,mBAAOvB,EAAE,CACPG,MADO,EAEPqB,SAFO,EAGP,UAAAC,KAAK,EAAI;AACP,kBAAMC,OAAO,GAAG3B,YAAY,CAAC0B,KAAD,EAAQnB,gBAAgB,CAACU,YAAzB,CAA5B,CADO,CAEP;;AACA,kBAAIU,OAAO,IAAI,CAAC,KAAI,CAACC,UAAL,CAAgBC,GAAhB,CAAoBF,OAApB,CAAhB,EAA8C;AAC5C,oBAAMG,SAAS,GAAG,KAAI,CAACpB,MAAL,CAAYiB,OAAZ,EAAqBrB,OAArB,CAAlB;;AACA,oBAAI,OAAOwB,SAAS,CAACC,cAAjB,KAAoC,UAAxC,EAAoD;AAClDD,kBAAAA,SAAS,CAACC,cAAV,CAAyBL,KAAzB;AACD;AACF;AACF,aAZM,EAaPF,IAAI,KAAK,OAAT,IAAoB,CAACN,UAbd,CAAT;AAeD,WAjBe,CAAhB;AAkBA,iBAAO;AACLc,YAAAA,OADK,qBACK;AACR,mBAAK,IAAIC,MAAM,GAAGZ,OAAO,CAACa,GAAR,EAAlB,EAAiCD,MAAjC,EAAyCA,MAAM,GAAGZ,OAAO,CAACa,GAAR,EAAlD,EAAiE;AAC/DD,gBAAAA,MAAM,CAACD,OAAP;AACD;AACF;AALI,WAAP;AAOD;;AACD,eAAO,EAAP;AACD;AA1D0B;;AAAA;AAAA,IAKM9B,KALN;;AAKvBC,EAAAA,oBALuB,CAUpBgC,WAVoB,GAUN,IAVM;AA4D7B,SAAOhC,oBAAP;AACD","sourcesContent":["import eventMatches from '../misc/event-matches';\nimport on from '../misc/on';\n\nexport default function(ToMix) {\n  /**\n   * Mix-in class to instantiate components upon events.\n   * @class InitComponentByEvent\n   */\n  class InitComponentByEvent extends ToMix {\n    /**\n     * `true` suggests that this component is lazily initialized upon an action/event, etc.\n     * @type {boolean}\n     */\n    static forLazyInit = true;\n\n    /**\n     * Instantiates this component in the given element.\n     * If the given element indicates that it's an component of this class, instantiates it.\n     * Otherwise, instantiates this component by clicking on this component in the given node.\n     * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.\n     * @param {Object} [options] The component options.\n     * @param {string} [options.selectorInit] The CSS selector to find this component.\n     * @returns {Handle} The handle to remove the event listener to handle clicking.\n     */\n    static init(target = document, options = {}) {\n      const effectiveOptions = Object.assign(Object.create(this.options), options);\n      if (!target || (target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE)) {\n        throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');\n      }\n      if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {\n        this.create(target, options);\n      } else {\n        // To work around non-bubbling `focus` event, use `focusin` event instead of it's available, and \"capture mode\" otherwise\n        const hasFocusin = 'onfocusin' in (target.nodeType === Node.ELEMENT_NODE ? target.ownerDocument : target).defaultView;\n        const handles = effectiveOptions.initEventNames.map(name => {\n          const eventName = name === 'focus' && hasFocusin ? 'focusin' : name;\n          return on(\n            target,\n            eventName,\n            event => {\n              const element = eventMatches(event, effectiveOptions.selectorInit);\n              // Instantiated components handles events by themselves\n              if (element && !this.components.has(element)) {\n                const component = this.create(element, options);\n                if (typeof component.createdByEvent === 'function') {\n                  component.createdByEvent(event);\n                }\n              }\n            },\n            name === 'focus' && !hasFocusin\n          );\n        });\n        return {\n          release() {\n            for (let handle = handles.pop(); handle; handle = handles.pop()) {\n              handle.release();\n            }\n          },\n        };\n      }\n      return '';\n    }\n  }\n  return InitComponentByEvent;\n}\n"]},"metadata":{},"sourceType":"module"}